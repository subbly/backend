//     Subbly.js v 0.1.0
//     (c) 2014-2015 Subbly.com

var SubblyCore = function( config )
{
  // APP'S Constants
  // -------------

  // Current version of the library.
  this._VERSION           = '0.1.0'

  // User credentials cookie's name
  this._CREDENTIALSCOOKIE = 'SubblyCredentials'

  // General note
  // -------------

  // we log as much as we can 
  console.info( 'Init Subbly object with this config:' )
  console.log( config )

  // Instance's properties
  // -------------

  // enviroment config' generated by `subbly/backend`
  this._config            = config

  // form state, allow us to display an warning popin
  // if user leave the page without save his change
  this._changesAreSaved   = true

  // current user's 'model
  this._user              = false

  // current user's credentials
  this._credentials       = false

  // list of all the XHR calls
  this._fetchXhr          = {}

  // Store settings
  this._storeSettings     = false

  // `i18n` class instance
  this._i18n = new i18n()

  // `Feedback` class instance
  this._feedback = new Feedback()

  // Pub/Sub channel,
  // extends the original `Backbone.Events`
  this._event  = _.extend( {}, Backbone.Events )

  // User login/logout Events
  this._event.on( 'user::loggedIn', this.setCredentials, this )
  this._event.on( 'user::logout',   this.logout,         this )

  // Names of the API's basic services
  // based on the Backbone's conventions
  this._viewAllowedType = [ 
      'Model'
    , 'Collection'
    , 'View'
    , 'ViewForm'
    , 'ViewList'
    , 'ViewListRow'
    , 'Controller' 
  ]

  // return Subbly reference
  return this
}


//  App Starter point
SubblyCore.prototype.init = function()
{
  console.info( 'Initialize App router' )
  console.info( 'Components list' )
  console.log( Components )

  // initialize Backbone's router
  this._router = new Router()

  var scope = this

  // Register global event `hash:change`. 
  // Trigger URL change.
  this.on( 'hash::change', function( href, trigger )
  {
    // define if URL change must call or not
    // the attached route
    trigger = ( _.isUndefined( trigger ) ) ? true : trigger

    // E.G.: this is usefull if you are in a new document form,
    // when you save the document you don't whant to reload the page
    // but you need to update the URL with the new document ID
    var opts = ( trigger ) 
               ? { trigger: true }
               : { replace: true } 

    // Call Backbone `navigate` 
    if( scope._changesAreSaved )
    {
      scope._router.navigate( href, opts )
    }
    // Or display confirmation modal if 
    // form's changes are not saved
    else
    {
      /*
      this._confirmModal = this.api('Subbly.View.Modal',
      {
          message:  __('label.form_leave')
        , success:  __('label.leave')
        , onSubmit: function()
          {
            scope.trigger( 'form::reset' )
            AppRouter.navigate( href, opts )
          }
      })
      */
    }
  })

  // If current user is not logged
  // trigger `user::login`
  if( !this.isLogin() )
  {
    console.info( 'trigger login view' )
    console.groupEnd()

    this.trigger( 'user::login' )
  }
  else
  {
    console.info( 'user is logged in' )
    console.info( 'release app router' )
    console.groupEnd()
  }
}


// Config
//-------------------------------

//  Get enviroment config' value
// 
//     @param   {string}   dot.notation path to the asked value
//     @param   {mixed}    default value
//     @return  {mixed}
//
SubblyCore.prototype.getConfig = function( path, defaults )
{
  return Helpers.getNested( this._config, path, defaults || false ) 
}

//  Set enviroment config' value
// 
//     @param   {string}   path to the value
//     @param   {mixed}    the value
//     @return  {void}
//
SubblyCore.prototype.setConfig = function( path, value )
{
  return Helpers.setNested( this._config, path, value ) 
}


// EVENTS
//-------------------------------

// Backbone's events shortcuts

// Bind an event to a `callback` function. Passing `"all"` will bind
// the callback to all events fired.
// 
//     @param   {string}   event's name
//     @param   {function} the callback
//     @param   {function} scope context
//     @return  {void}
//
SubblyCore.prototype.on = function( name, callback, context )
{
  this._event.on( name, callback, context )
}

// Bind an event to only be triggered a single time. After the first time
// the callback is invoked, it will be removed.
// 
//     @param   {string}   event's name
//     @param   {function} the callback
//     @param   {function} scope context
//     @return  {void}
//
SubblyCore.prototype.once = function( name, callback, context )
{
  this._event.once( name, callback, context )
}


// Remove one or many callbacks. If `context` is null, removes all
// callbacks with that function. If `callback` is null, removes all
// callbacks for the event. If `name` is null, removes all bound
// callbacks for all events.
//
//     @return  {void}
//

SubblyCore.prototype.off = function( name, callback, context )
{
  this._event.off( name, callback, context )
}

// Trigger one or many events, firing all bound callbacks. Callbacks are
// passed the same arguments as `trigger` is, apart from the event name
// (unless you're listening on `"all"`, which will cause your callback to
// receive the true name of the event as the first argument).
// 
//     @return  {void}
//
// TODO: `args1... oh my god ! need to find a better solution
SubblyCore.prototype.trigger = function( args1, args2, args3, args4, args5, args6, args7 )
{
/*
var args = [].slice.call( arguments, 1 )
console.log( arguments )
this._event.trigger.apply( this, arguments )
*/

  this._event.trigger( args1, args2, args3, args4, args5, args6, args7 )
}


// SHORTCUTS
//-------------------------------

// `Feedback`'s class instance shortcust
//
//    @return  {object}
//
SubblyCore.prototype.feedback = function()
{
  return this._feedback
}

// `I18n`'s class instance shortcust
//
//    @return  {string}
//
SubblyCore.prototype.i18n = function()
{
  return this._i18n
}

// Store settings shortcuts access
// 
//    @return  {object}
//
SubblyCore.prototype.storeSettings = function()
{
  return this._storeSettings
}


// CREDENTIALS / LOGIN
//-------------------------------



// Set user credentials.
// Load user settings and locales
//
//     @param   {string}   `Basic Auth` encoded string
//     @return  {void}
//
SubblyCore.prototype.setCredentials = function( credentials )
{
  console.info('Set user credentials')

  this._credentials = credentials

  this.setCookie( this._CREDENTIALSCOOKIE, this._credentials )

  this._storeSettings = this.api('Subbly.Model.Settings')

  var scope = this

  this.fetch( this._storeSettings,
  {
    success: function( model, response )
    {
      scope.i18n().setLocale( scope.getSetting('subbly.backend_language'), function()
      {
        scope._router.ready(function( route )
        {
          scope.trigger( 'hash::changed', route )
        })
      })
    }
  }, this )
}


// Return current user `Basic Auth` encoded credentials
//
//     @return  {object}
//
SubblyCore.prototype.getCredentials = function()
{
  if( !this._credentials )
    throw new Error( 'User credentials are not set' )

  return this._credentials
}


// Check if current user is logged in
// If `true`, trigger `user::loggedIn` event
//
//     @return  {boolean}
//
SubblyCore.prototype.isLogin = function()
{
  var credentials = this.getCookie( this._CREDENTIALSCOOKIE )

  if( !credentials )
    return false
  
  this.trigger( 'user::loggedIn', credentials )

  return true
}


// Unset user credentials. 
// Trigger `user::login` event
//
//     @return  {void}
//
SubblyCore.prototype.logout = function()
{
  console.info( 'user logout' )

  this._credentials = false

  this.setCookie( this._CREDENTIALSCOOKIE, null )

  this.trigger( 'user::login' )
}


// API
//-------------------------------



// Format full URL to API service
// based on evironement config'
//
//     @params  {string}  service's URL
//     @return  {string}
//
SubblyCore.prototype.apiUrl = function( url )
{
  return this._config.apiUrl + url
}


// Return formated user's `Basic Auth` Header
//
//     @return  {object}
//
SubblyCore.prototype.apiHeader = function()
{
  return {
    Authorization: 'Basic ' + this._credentials
  }
}


// Call a service protected by closure
//
//     @params  {string}  service name
//     @params  {object}  service arguments
//     @return  {mixed}
//
SubblyCore.prototype.api = function( serviceName, args )
{
  var service = Helpers.getNested( Components, serviceName, false )
    , args    = args || {}

  if( !service )
    throw new Error( 'Subbly API do not include ' + serviceName )

  // if it's a Backbone's element ( a.k.a. a model, collection or view)
  // we create a new instance
  if( _.isFunction( service ) )
    return new service( args )

  return service
}


// Generic method to fetch model/collection.
// Stores the XHR call which allows the abort on route change.
// Trigger local loading event
//
//     @params  {object}  object to fetch
//     @params  {object}  data and callbacks options
//     @params  {object}  call context
//     @return  {object}
//
SubblyCore.prototype.fetch = function( obj, options, context )
{
  var options   = options || {}
    , xhrId     = _.uniqueId( 'xhr_' )

  if( context )
    context.trigger( 'fetch::calling' )
  
  this._fetchXhr[ xhrId ] = obj.fetch({
      data:    options.data || {} 
    , xhrId:   xhrId
    , success: function( bbObj, response, opts )
      {
        if( context )
          context.trigger( 'fetch::responds' )

        if( options.success && _.isFunction( options.success ) )
          options.success( bbObj, response, opts )
      }
    , error: function( bbObj, response, opts )
      {
        if( context )
          context.trigger( 'fetch::responds' )

        if( options.error && _.isFunction( options.error ) )
          options.error( bbObj, response, opts  )
      }
  })
}


// Generic method to save a model.
// Format json aand
// stores the XHR call to prevent cancel
//
//     @params  {object}  model to save
//     @params  {object}  data to set
//     @params  {object}  callbacks options
//     @params  {object}  call context
//     @return  {object}
//
SubblyCore.prototype.store = function( model, data, options, context )
{
  var data    = data || false
    , options = options || {}
    , scope   = this

  if( !data )
    throw new Error( 'No data pass to Subbly.store' )

  var _feedback = this.feedback()
  
  _feedback.add().progress()

  var settings = $.extend({
      success: function( model, response, opts )
      {
        model.clear()
        model.set( response.response[ model.singleResult ] )

        _feedback.progressEnd( 'success', options.successMsg || response.headers.status.message )

        if( options.onSuccess && _.isFunction( options.onSuccess ) )
          options.onSuccess( model, response, opts )
      }
    , error: function( model, response, opts )
      {
        _feedback.progressEnd( 'error', options.errorMsg || response.responseJSON.headers.status.message )

        if( options.onError && _.isFunction( options.onError ) )
          options.onError( model, response, opts  )
      }
  }, options )

  options.json = {}

  options.json[ model.singleResult ] = data 

  options.json = $.extend( {}, options.json, model.getAdditonalParams() )

  model.save( options.json, settings )
}


// Abort unfinish XHR call on route change
//
//     @return  {void}
//
SubblyCore.prototype.cleanXhr = function()
{
  _( this._fetchXhr )
    .forEach( function( xhr, key )
    {
      if( xhr.readyState > 0 && xhr.readyState < 4 )
        xhr.abort()

      delete this._fetchXhr[ key ]
    }, this)
}


// SETTINGS
//-------------------------------


// Get current settings 
//
//     params  {string}  settings key (optional)
//     return  {mixed}
//
SubblyCore.prototype.getSetting = function( key, defaults )
{
  if( _.isUndefined( key ) )
    return this._storeSettings.attributes

  return this._storeSettings.get( key )
  // return Helpers.getNested( this._storeSettings, key, defaults || false )
}


// COOKIES
//-------------------------------


// get Cookie
//
//     return  {mixed}
//
SubblyCore.prototype.getCookie = function( cookieName )
{
  console.groupCollapsed( 'get cookie: ' + cookieName )

  if( !document.cookie )
  {
    console.warn('no cookie for this domain')
    console.groupEnd()
    return false
  }

  // retrive data from cookies
  var data = decodeURIComponent( document.cookie.replace( new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent( cookieName ).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null
  
  console.log( document.cookie )
  console.log( data )
  
  if( data === 'null' )
  {
    console.warn('cookie "' + cookieName + '" found but data are null')
    console.groupEnd()

    return false
  }

  console.groupEnd()
  return data
}

// set Cookie
//
//     return  {void}
//
SubblyCore.prototype.setCookie = function( cookieName, value, expire )
{
  document.cookie = cookieName + '=' + value + '; path=/'
}


// PLUGINS
//-------------------------------


// Extend Subbly Components
//
//     params  {string}  component type
//     params  {string}  component name
//     params  {object}  component object
//     return  {void}
//
SubblyCore.prototype.extend = function( vendor, type, name, obj )
{
  if( this._viewAllowedType.indexOf( type ) == -1 )
    throw new Error( 'Extend can not accept "' + type + '" as extend' )

  // create a new Vendor
  if( !Components[ vendor ] )
    Components[ vendor ] = defautlsFwObj()

  var alias

  switch( type )
  {
    case 'Controller':
        alias = SubblyController
      break
    case 'View':
        alias = SubblyView
      break
    case 'ViewForm':
        type  = 'View' 
        alias = SubblyViewForm
      break
    case 'ViewList':
        type  = 'View' 
        alias = SubblyViewList
      break
    case 'ViewListRow':
        type  = 'View' 
        alias = SubblyViewListRow
      break
    case 'Model':
        alias = SubblyModel
      break
    case 'Collection':
        alias = SubblyCollection
      break
    case 'CollectionList':
        alias = SubblyCollectionList
      break
  }

  if( Components[ vendor ][ type ][ name ] )
  {
    // TODO: extend existing components + log 
    throw new Error( vendor + '.'  + type + '.'  + name + ' already exist' )
  }

  Components[ vendor ][ type ][ name ] = alias.extend( obj )
}

// Register Plugin
//
//     params  {object}  plugin object
//     return  {void}
//
SubblyCore.prototype.register = function( vendor, name, plugin )
{
  console.groupCollapsed( 'Register Plugin ' + vendor + '.' + name )

  _.each( plugin, function( component, typeName )
  {
    var arr = typeName.split(':')

    this.extend( vendor, arr[0], arr[1], component )
  }, this )

  console.groupEnd()
}

// Global Init

console.groupCollapsed( 'Subbly Global Init' )
// console.group( 'Subbly Global Init' )

window.Subbly = new SubblyCore( subblyConfig )



